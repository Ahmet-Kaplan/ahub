test <- function(...){
list(...)
}
test(1,2,3)
test(a=1,s=2,k=3)
?assign
names(test(a=1,s=2,k=3))
test <- function(...){
for(v in list(...)){
cat(v)
cat(names(v))
}
}
test(a=1,s=2,k=3)
test <- function(...){
for(v in list(...)){
print(v)
print(names(v))
}
}
test(a=1,s=2,k=3)
test <- function(...){
l <- list(...)
for(v in names(l)){
l[v]
v
}
}
test(a=1,s=2,k=3)
test <- function(...){
l <- list(...)
for(v in names(l)){
print(l[v])
print(v)
}
}
test(a=1,s=2,k=3)
test <- function(...){
l <- list(...)
for(v in names(l)){
print(l[[v]])
print(v)
}
}
test(a=1,s=2,k=3)
test <- function(...){
arglist <- list(...)
for(arg in names(arglist)){
print(arglist[[arg]])
print(arg)
}
}
test(a=1,s=2,k=3)
test2 <- function(...){
print(...)
}
test(a=1,s=2,k=3)
test2(a=1,s=2,k=3)
test2 <- function(...){
typeof(...)
}
test2(a=1,s=2,k=3)
?"..."
test2 <- function(...){
k <- ...
}
test2(a=1,s=2,k=3)
k <- ...elt(1)
test2 <- function(...){
k <- ...elt(1)
}
test2(a=1,s=2,k=3)
test2 <- function(...){
k <- ...elt(1)
k
}
test2(a=1,s=2,k=3)
dummy(list(t=1))
?do.call
test2 <- function(...){
list(...)
}
test2(a=1,s=2,k=3)
test2()
library(ahubr)
ahubr:::mybatch()
ahubr:::mybatch()
ahubr:::mybatch()
ahubr:::mybatch()
ahubr:::mybatch()
process_name <- "lollo"
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
pid_info
# unpack ...
arglist <- list()
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
fun <- dummy
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
f
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
if(!exists(arglist)) arglist <- list()
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
if(!exists("arglist")) arglist <- list()
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
f
arglist
fun
arglist<-list(t=1)
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
if(!exists("arglist")) arglist <- list()
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
#' Title
#'
#' @return
#' @export
#'
#' @import future
#'
#' @examples
init_future <- function(){
if(!.ahubEnv$future_init){
status <- try(plan(multisession()), silent=TRUE)
if(!inherits(status, 'try-error')){
assign("future_init", TRUE, envir = .ahubEnv)
return(TRUE)
}else{
flog.error('Could not initialise multisession future for batch processing.')
return(FALSE)
}
}else{
return(TRUE)
}
}
status <- try(plan(multisession, silent=TRUE)
if(!inherits(status, 'try-error')){
assign("future_init", TRUE, envir = .ahubEnv)
return(TRUE)
}else{
flog.error('Could not initialise multisession future for batch processing.')
return(FALSE)
}
}else{
return(TRUE)
}
}
#' Title
#'
#' @param t
#'
#' @return
#' @export
#'
#' @examples
dummy <- function(t = 1){
Sys.sleep(t)
}
testbatch <- dummy %>% as_batch_function()
status <- try(plan(multisession), silent=TRUE)
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
if(!exists("arglist")) arglist <- list()
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
f
value(f)
# unpack ...
arglist <- list()
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
if(!exists("arglist")) arglist <- list()
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
value(f)
library(ahubr)
ahubr:::testbatch()
ahubr:::testbatch()
ahubr:::testbatch()
ahubr:::testbatch()
ahubr:::testbatch()
mybatch <- dummy %>% as_batch_function("sajkhkjahsd")
mybatch()
mybatch()
mybatch()
mybatch()
mybatch()
mybatch <- dummy %>% as_batch_function("sajkhkjahsd")
mybatch()
mybatch()
get_pid_log(1007)
get_pid_log(1006)
print(fun)
library(ahubr)
mybatch <- dummy %>% as_batch_function("djskfhksufh")
mybatch()
#' @param fun
#' @param process_name
#'
#' @return
#' @export
#'
#' @import glue future futile.logger
#' @importFrom magrittr %>%
#'
#' @examples
as_batch_function <- function(myfun,
process_name = "test") {
function(force = F, ...) {
#process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# has the process already finished today
run_today <-
pid_info$time %>% substr(1, 8) %>% lubridate::ymd() == Sys.Date() &
pid_info$status == 'finished'
# check if process has not run today and is not finished and force is FALSE
if (!run_today | as.numeric(force)) {
# if yes, check if process is not running
if (pid_info$status != 'running' & init_future()) {
# if yes start process
if (pid_info$status != 'init') pid <- create_pid(process_name)
flog.info(environmentName(parent.frame()))
# unpack ...
arglist <- list(...)
print(myfun)
print(arglist)
f <- future({
# init logging
pid_log(pid, glue('Process {process_name} started.'))
set_pid_status(pid, 'running')
if(!exists("arglist")) arglist <- list()
# do some stuff ##################
do.call(fun, arglist)
#################################
# wrap up
pid_log(pid, glue('Process {process_name} finished'))
set_pid_status(pid, 'finished')
return(TRUE)
}, packages=c("futile.logger", "glue", "ahubr"),
globals = c("pid", "process_name", "fun", "arglist")
)
output <-
list(
msg = glue("Process {process_name} started."),
log = get_pid_log(pid),
status = 'started',
pid = pid
)
} else{
# if not return log and status
output <-
list(
msg = glue("Process {process_name} currently running."),
log = get_pid_log(pid),
status = 'running',
pid = pid
)
}
} else{
# if not, do nothing and return log
output <- list(
msg = glue("Process {process_name} finished!"),
log = get_pid_log(pid),
status = 'finished',
pid = pid
)
}
output
}
}
mybatch <- dummy %>% as_batch_function("djskfhksufh")
mybatch()
library(ahubr)
mybatch <- dummy %>% as_batch_function()
mybatch()
library(ahubr)
mybatch <- dummy %>% as_batch_function()
mybatch()
mybatch
library(ahubr)
dummy %>% as_batch_function()
roxygen2::roxygenise()
library(ahubr)
dummy %>% as_batch_function()
dummy %>% as_batch_function()
library(ahubr)
mybatch <- dummy %>% as_batch_function()
mybatch()
mybatch()
mybatch()
myfun
library(ahubr)
dummy %>% as_batch_function()
dummy %>% as_batch_function()
dummy %>% as_batch_function("sdkjhsdd")
dummy %>% as_batch_function(process_name = "sdkjhsdd")
library(ahubr)
dummy %>% as_batch_function(process_name = "sdkjhsdd")
dummy %>% as_batch_function(process_name = "sdkjhsdd")
dummy %>% as_batch_function(process_name = "sdkjhsdd", force=F)
dummy %>% as_batch_function(process_name = "sdkjhsdd", force=F, arglist=list(t=5))
dummy %>% as_batch_function(process_name = "sdkjhsdd", force=T, arglist=list(t=5))
dummy %>% as_batch_function(process_name = "sdkjhsdd", force=T, arglist=list(t=5))
dummy %>% as_batch_function(process_name = "sdkjhsdd", force=T, arglist=list(t=5))
?get
get_current_pid <- function(){
get("pid", envir = parent.frame())
}
test <- function(){
pid <- 10
get_current_pid()
}
pid <- 12
test()
get("lkslks")
?get
roxygen2::roxygenise()
test <- function(){
pid <- 10
bosslog("test")
}
test()
library(ahubr)
test <- function(){
pid <- 10
bosslog("test")
}
test()
environment()
parent.frame()
parent.frame(parent.frame())
parent.env(parent.frame()
)
library(ahubr)
test <- function(){
pid <- 10
bosslog("test")
}
test()
get_pid_log(10)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
library(ahubr)
dummy %>% daily_batch_process(process_name = "sdkjhsdd",
force = T,
arglist = list(t = 5))
dummy_process %>% daily_batch_process(process_name = "sdkjhsdd",
force = T,
arglist = list(t = 5))
dummy_process %>% daily_batch_process(process_name = "sdkjhsdd",
force = T,
arglist = list(t = 5))
dummy_process %>% daily_batch_process(process_name = "sdkjhsdd",
force = T,
arglist = list(t = 5))
dummy_process %>% daily_batch_process(process_name = "sdkjhsdd",
force = F,
arglist = list(t = 5))
dummy_process %>% daily_batch_process(process_name = "sdkjhsdd",
force = F,
arglist = list(t = 5))
library(ahubr)
library(ahubr)
library(ahubr)
ahubr:::.ahubEnv$debug
library(roxygen2)
roxygenise()
library(ahubr)
library(ahubr)
roxygenise()
roxygenise()
library(ahubr)
roxygen2::roxygenise()
library(ahubr)
library(ahubr)
library(ahubr)
library(ahubr)
switch_debug()
get_pid("lol")
get_pid("nooois")
create_pid("lol")
library(ahubr)
switch_debug()
create_pid('shkdhads')
library(ahubr)
library(ahubr)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
library(ahubr)
library(ahubr)
?daily_batch_process
library(ahubr)
?daily_batch_process
?daily_batch_process
library(ahubr)
library(ahubr)
?daily_batch_process
roxygen2::roxygenise()
?daily_batch_process
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
library(ahubr)
roxygen2::roxygenise()
library(ahubr)
?init_boss_api
roxygen2::roxygenise()
library(ahubr)
