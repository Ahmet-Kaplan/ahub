return(TRUE)
}
output <- list(msg=glue("Process {process_name} started..."),
log=get_pid_log(pid),
status = 'started')
} else{ # if not return log and status
output <- list(msg=glue("Process {process_name} currently running..."),
log=get_pid_log(pid),
status = 'running')
}
} else{ # if not, do nothing and return log
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
}
output
}
get_pid(process_name) # get the last process id for this process
get_pid(process_name)
# gets the latest pid for a process or create a new one if never run before
get_pid <- function(process_name){
pid <- redisZRange(process_name, -1, -1)
if(is.null(pid)) pid <- create_pid(process_name)
return(pid)
}
get_pid(process_name)
#* Run FTA forecast on full dataset from DB
#* @param force [1,0] force execution when process was already run today
#* @param t time to execute process
#* @get /batch
#* @json
batch <- function(force = 0, t = 20) {
nodename <- Sys.info()[["nodename"]]
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
# check if process has not run today and is not finished and force is FALSE
if (!run_today | as.numeric(force)) {
# if yes, check if process is not running
if(pid_info$status != 'running') {
# if yes start process
if(pid_info$status != 'init') pid <- create_pid(process_name)
result %<-% {
# init logging
redisConnect()
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
Sys.sleep(t)
##################################
# wrap up
flog.info('Process %s finished', process_name)
set_pid_status(pid, 'finished')
return(TRUE)
}
output <- list(msg=glue("Process {process_name} started..."),
log=get_pid_log(pid),
status = 'started')
} else{ # if not return log and status
output <- list(msg=glue("Process {process_name} currently running..."),
log=get_pid_log(pid),
status = 'running')
}
} else{ # if not, do nothing and return log
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
}
output
}
batch(t=5)
batch(t=5)
batch(t=5)
batch(t=5)
batch(t=5)
batch(t=5)
batch(t=5)
batch(t=5)
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
dummy_process <- function(t, steps=5){
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
for(k in 1:steps){
flog.info('Executing process step %s', k)
Sys.sleep(t / steps)
}
}
line <- "INFO [2018-07-26 15:58:26] Process batch finished\n"
cat(line, sep = "")
pidf
pid
str_replace(line, '(\\[.+\\])', '\\1 pid')
?str_replace
glue::glue('\\1 PID {pid}:')
str_replace(line, '(\\[.+\\])', glue::glue('\\1 PID {pid}:'))
line <- line %>%
str_replace('(\\[.+\\])', glue::glue('\\1 PID {pid}:')) %>%
str_replace('\n', '')
line
# custom appender function for the packages futile.logger
# writes log to redis list log:[pid] instead of file
appender.redis <- function(pid){
function(line){
line <- line %>%
str_replace('(\\[.+\\])', glue::glue('\\1 PID {pid}:')) %>%
str_replace('\n', '')
cat(line, sep = "")
redisLPush(paste0('log:', pid), charToRaw(line))
}
}
#* Run FTA forecast on full dataset from DB
#* @param force [1,0] force execution when process was already run today
#* @param t time to execute process
#* @get /batch
#* @json
batch <- function(force = 0, t = 20) {
nodename <- Sys.info()[["nodename"]]
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
# check if process has not run today and is not finished and force is FALSE
if (!run_today | as.numeric(force)) {
# if yes, check if process is not running
if(pid_info$status != 'running') {
# if yes start process
if(pid_info$status != 'init') pid <- create_pid(process_name)
result %<-% {
# init logging
redisConnect()
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
# wrap up
flog.info('Process %s finished', process_name)
set_pid_status(pid, 'finished')
return(TRUE)
}
output <- list(msg=glue("Process {process_name} started..."),
log=get_pid_log(pid),
status = 'started')
} else{ # if not return log and status
output <- list(msg=glue("Process {process_name} currently running..."),
log=get_pid_log(pid),
status = 'running')
}
} else{ # if not, do nothing and return log
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
}
output
}
dummy_process <- function(t, steps=5){
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
for(k in 1:steps){
flog.info('Executing process step %s', k)
Sys.sleep(t / steps)
}
}
batch(t=5)
batch(1, 5)
batch(1, 5)
batch(0, 5)
get_pid_log(1002)
%>% cat
get_pid_log(1002) %>% cat
get_pid_log(1002) %>% print
source('~/Repos/QAF/node/redis_functions.R', echo=TRUE)
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
# clean ip process ids which are still on status "running"
redissrv <- ifelse(interactive(), 'localhost', 'redis_qaf')
?redisConnect
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
flog.appender()
?flog.appender
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid), name=pid)
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
redisSMembers('process_names')
redisSAdd('process_names', charToRaw(process_name))
process_name <- "thread"
redisSAdd('process_names', charToRaw(process_name))
redisSMembers('process_names')
redisSRem('process_names', 'thread')
redisSMembers('process_names')
redisSRem('process_names', 'batch')
redisSMembers('process_names')
sapply(redisSMembers('process_names'),
redisZRange, start=0, end=-1)
lapply(redisSMembers('process_names'),
redisZRange, start=0, end=-1)
?sapply
redisSMembers('process_names')
redisSMembers('process_names') %>% unlist
lapply(redisSMembers('process_names') %>% unlist,
redisZRange, start=0, end=-1)
sapply(redisSMembers('process_names') %>% unlist,
redisZRange, start=0, end=-1)
sapply(redisSMembers('process_names') %>% unlist,
function(x) redisZRange(x, start=0, end=-1) %>% unlist)
# retrieve all pid's for all process_names
get_all_processes <- function(){
sapply(redisSMembers('process_names') %>% unlist,
function(x) redisZRange(x, start=0, end=-1) %>% unlist)
}
pidlist <- get_all_processes()
x <- pidlist[[1]]
x
sapply(x, function(x) redisLRange(paste0('log:', x), 0, -1))
sapply(x, function(x) redisLRange(paste0('log:', x), 0, -1) %>% unlist)
sapply(pidlist, function(x)	sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist))
sapply(pidlist, function(x)	sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist)) %>% as_tibble()
sapply(pidlist, function(x)	sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist)) %>% tribble()
?tribble
sapply(pidlist, function(x)
sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist)
) %>% tribble()
#sapply(pidlist, function(x)
sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist)
#sapply(pidlist, function(x)
sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist) %>% tibble
#sapply(pidlist, function(x)
sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist) %>% tibble(log)
#sapply(pidlist, function(x)
tibble(log=sapply(x, function(y) redisLRange(paste0('log:', y), 0, -1) %>% unlist))
#sapply(pidlist, function(x)
for(p in pidlist){
}
p
logs <- sapply(p, function(x) redisLRange(paste0('log:', x), 0, -1) %>% unlist)
logs_df <- tibble(pid = p, log = logs)
logs_df
logs <- sapply(p, function(x) redisLRange(paste0('log:', x), 0, -1) %>% unlist)
logs
pidlist
k <- 1
logs <- sapply(pidlist[[k]], function(x) redisLRange(paste0('log:', x), 0, -1) %>% unlist)
logs
logs_df <- tibble(process = names(pidlist)[k], pid = pidlist[[k]], log = logs)
logs_df
logslist <- list()
p <- pidlist[[1]]
#p <- pidlist[[1]]
#sapply(pidlist, function(x)
for(k in 1:length(pidlist)){
logs <- sapply(pidlist[[k]], function(x) redisLRange(paste0('log:', x), 0, -1) %>% unlist)
logslist[[k]] <- tibble(process = names(pidlist)[k], pid = pidlist[[k]], log = logs)
}
logslist
bind_rows(logslist)
bind_rows(logslist) %>% arrange(pid)
# retrieve all pid's for all process_names
get_all_pids <- function(){
sapply(redisSMembers('process_names') %>% unlist,
function(x) redisZRange(x, start=0, end=-1) %>% unlist)
}
get_all_logs <- function(){
pidlist <- get_all_pids()
logslist <- list()
#p <- pidlist[[1]]
#sapply(pidlist, function(x)
for(k in 1:length(pidlist)){
logs <- sapply(pidlist[[k]], function(x) redisLRange(paste0('log:', x), 0, -1) %>% unlist)
logslist[[k]] <- tibble(process = names(pidlist)[k], pid = pidlist[[k]], log = logs)
}
bind_rows(logslist) %>% arrange(pid)
#) %>% tribble()
}
get_all_logs <- function(){
pidlist <- get_all_pids()
logslist <- list()
#p <- pidlist[[1]]
#sapply(pidlist, function(x)
for(k in 1:length(pidlist)){
logs <- sapply(pidlist[[k]], function(x) redisLRange(paste0('log:', x), 0, -1) %>% unlist)
logslist[[k]] <- tibble(process = names(pidlist)[k], pid = pidlist[[k]], log = logs)
}
bind_rows(logslist) %>% arrange(pid)
}
get_all_logs
get_all_logs()
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
library(future)
library(futile.logger)
library(readr)
library(rredis)
library(glue)
plan(multisession)
# REDIS INIT
# ----------------------------------------
# Connect to redis
source('redis_functions.R')
redissrv <- ifelse(interactive(), 'localhost', 'redis')
redisConnect(host=redissrv)
# Connect to redis
source('redis_functions.R')
# Connect to redis
source('redis_functions.R')
setwd("~/Repos/QAF/node")
# Connect to redis
source('redis_functions.R')
redissrv <- ifelse(interactive(), 'localhost', 'redis')
redisConnect(host=redissrv)
?redisConnect
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
gsub
?gsub
source('~/Repos/QAF/node/redis_functions.R', echo=TRUE)
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
#* Batch process running t seconds
#* @param force [1,0] force execution when process was already run today
#* @param t time to execute process
#* @get /batch
#* @json
batch <- function(force = 0, t = 20) {
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
# check if process has not run today and is not finished and force is FALSE
if (!run_today | as.numeric(force)) {
# if yes, check if process is not running
if(pid_info$status != 'running') {
# if yes start process
if(pid_info$status != 'init') pid <- create_pid(process_name)
result %<-% {
# init logging
redisConnect()
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid), name=pid)
flog.info('Process %s started', process_name, name=pid)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
# wrap up
flog.info('Process %s finished', process_name, name=pid)
set_pid_status(pid, 'finished')
return(TRUE)
}
output <- list(msg=glue("Process {process_name} started..."),
log=get_pid_log(pid),
status = 'started')
} else{ # if not return log and status
output <- list(msg=glue("Process {process_name} currently running..."),
log=get_pid_log(pid),
status = 'running')
}
} else{ # if not, do nothing and return log
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
}
output
}
btach()
batch()
traceback()
library(stringr)
batch()
batch()
batch()
get_all_pids()
get_all_logs()
library(dplyr)
get_all_logs()
batch()
pid_info$status
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
pid_info
pid
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
run_today
!run_today | as.numeric(force)
result %<-% {
# init logging
redisConnect()
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid), name=pid)
flog.info('Process %s started', process_name, name=pid)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
# wrap up
flog.info('Process %s finished', process_name, name=pid)
set_pid_status(pid, 'finished')
return(TRUE)
}
get_pid_log(pid)
get_pid_log(pid)
flog.info()
flog.info("lol"
)
?flog.appender
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
get_pid_log(pid)
set_pid_status(pid, 'running')
#* Batch process running t seconds
#* @param force [1,0] force execution when process was already run today
#* @param t time to execute process
#* @get /batch
#* @json
batch <- function(force = 0, t = 20) {
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
# check if process has not run today and is not finished and force is FALSE
if (!run_today | as.numeric(force)) {
# if yes, check if process is not running
if(pid_info$status != 'running') {
# if yes start process
if(pid_info$status != 'init') pid <- create_pid(process_name)
result %<-% {
# init logging
redisConnect()
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
# wrap up
flog.info('Process %s finished', process_name)
set_pid_status(pid, 'finished')
return(TRUE)
}
output <- list(msg=glue("Process {process_name} started..."),
log=get_pid_log(pid),
status = 'started')
} else{ # if not return log and status
output <- list(msg=glue("Process {process_name} currently running..."),
log=get_pid_log(pid),
status = 'running')
}
} else{ # if not, do nothing and return log
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
}
output
}
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
dummy_process <- function(t, steps=5){
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
for(k in 1:steps){
flog.info('Executing process step %s', k)
Sys.sleep(t / steps)
}
}
batch()
batch()
batch(force=1)
batch(force=1)
cleanup_pids()
batch(force=1)
batch(force=1)
batch(force=1)
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
?redisConnect
?try
rediscon <- try(redisConnect(host=redissrv, returnRef = T), silent=T)
