#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
# wrap up
flog.info('Process %s finished', process_name)
set_pid_status(pid, 'finished')
return(TRUE)
}
output <- list(msg=glue("Process {process_name} started..."),
log=get_pid_log(pid),
status = 'started')
} else{ # if not return log and status
output <- list(msg=glue("Process {process_name} currently running..."),
log=get_pid_log(pid),
status = 'running')
}
} else{ # if not, do nothing and return log
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
}
output
}
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
batch()
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
source('~/Repos/QAF/node/api.R', echo=TRUE)
force = 0
t <- 5
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid
pid_info <- get_pid_info(pid) # get the info to the pid
pid_info
pid
pid_info$time
pid_info$time %>% str_sub(1,8) %>% ymd()
pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date()
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
run_today
!run_today | as.numeric(force)
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
output
batch()
batch(force=1)
batch(force=1)
batch(force=1)
batch(force=1)
batch(force=1)
batch(force=1)
batch(force=1)
batch(force=1)
get_pid('batch')
redisConnect()
get_pid('batch')
Sys.time()
process_name <- 'thread' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid
pid_info <- get_pid_info(pid) # get the info to the pid
pid_info
redisFlushDB()
pid <- get_pid(process_name) # get the last process id for this process
process_name
pid
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
pid_info
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
run_today
!run_today | as.numeric(force)
pid_info$status != 'running'
pid_info$status != 'init'
result %<-% {
# init logging
redisConnect()
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
# wrap up
flog.info('Process %s finished', process_name)
set_pid_status(pid, 'finished')
return(TRUE)
}
result
batch(1)
batch(1)
batch(1)
batch(1)
batch(1)
batch(1)
?Sys.time
Sys.date()
Sys.Date
Sys.Date()
Sys.time(9)
Sys.time()
Sys.time() %>% as.POSIXct(tz="UTC")
Sys.timezone()
as.POSIXct()
?as.POSIXct
Sys.time() %>% as.POSIXct(tz="GMT")
Sys.time() %>% sf() %>% gsub('\\.', '', .)
Sys.time(tz='GMT')
Sys.time() %>% as.POSIXlt()
Sys.time() %>% as.POSIXlt(tz='GMT')
Sys.time() %>% as.POSIXct(tz='GMT')
Sys.time() %>% as.POSIXlt(tz='GMT')
redisFlushAll()
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
#* thread
#* @param t process time
#* @get /thread
#* @json
thread <- function(t = 1) {
# init logging
process_name <- 'thread' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# icheck if process is running or finished, if yes create new pid
if(pid_info$status != 'init') pid <- create_pid(process_name)
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid), name=pid)
flog.info('Process %s started', process_name, name=pid)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
set_pid_status(pid, 'finished')
# wrap up
flog.info('Process %s finished', process_name, name=pid)
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
output
}
thread()
redissrv <- ifelse(interactive(), 'localhost', 'redis')
rediscon <- try(redisConnect(host=redissrv, returnRef = T), silent=T)
# init pid if not exists
redisSet('next_pid', charToRaw('1000'), NX =TRUE)
# clean ip process ids which are still on status "running"
cleanup_pids()
thread()
#* thread
#* @param t process time
#* @get /thread
#* @json
thread <- function(t = 1) {
# init logging
process_name <- 'thread' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# icheck if process is running or finished, if yes create new pid
if(pid_info$status != 'init') pid <- create_pid(process_name)
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
set_pid_status(pid, 'finished')
# wrap up
flog.info('Process %s finished', process_name)
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
output
}
thread(9)
#* thread
#* @param t process time
#* @get /thread
#* @json
thread <- function(t = 1) {
# init logging
process_name <- 'thread' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# icheck if process is running or finished, if yes create new pid
if(pid_info$status != 'init') pid <- create_pid(process_name)
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(t)
##################################
set_pid_status(pid, 'finished')
# wrap up
flog.info('Process %s finished', process_name)
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
output
}
thread()
dummy_process <- function(pid, t, steps=5){
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
for(k in 1:steps){
flog.info('Executing process step %s', k)
Sys.sleep(t / steps)
}
}
#* Batch process running t seconds
#* @param force [1,0] force execution when process was already run today
#* @param t time to execute process
#* @get /batch
#* @json
batch <- function(force = 0, t = 20) {
process_name <- 'batch' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# has the process already finished today
run_today <- pid_info$time %>% str_sub(1,8) %>% ymd() == Sys.Date() &
pid_info$status == 'finished'
# check if process has not run today and is not finished and force is FALSE
if (!run_today | as.numeric(force)) {
# if yes, check if process is not running
if(pid_info$status != 'running') {
# if yes start process
if(pid_info$status != 'init') pid <- create_pid(process_name)
result %<-% {
# init logging
redisConnect(redissrv)
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(pid, t)
##################################
# wrap up
flog.info('Process %s finished', process_name)
set_pid_status(pid, 'finished')
return(TRUE)
}
output <- list(msg=glue("Process {process_name} started..."),
log=get_pid_log(pid),
status = 'started')
} else{ # if not return log and status
output <- list(msg=glue("Process {process_name} currently running..."),
log=get_pid_log(pid),
status = 'running')
}
} else{ # if not, do nothing and return log
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
}
output
}
dummy_process <- function(pid, t, steps=5){
flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
for(k in 1:steps){
flog.info('Executing process step %s', k)
Sys.sleep(t / steps)
}
}
#* thread
#* @param t process time
#* @get /thread
#* @json
thread <- function(t = 1) {
# init logging
process_name <- 'thread' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# icheck if process is running or finished, if yes create new pid
if(pid_info$status != 'init') pid <- create_pid(process_name)
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(pid, t)
##################################
set_pid_status(pid, 'finished')
# wrap up
flog.info('Process %s finished', process_name)
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
output
}
thread()
redisFlushAll()
shiny::runApp('~/Repos/QAF/client')
?tabBox
runApp('~/Repos/QAF/client')
errmsg <- try({
node1 <- get_node_api(host = hostname, port = 443, dir="node1", uid='test', pwd='test')
node2 <- get_node_api(host = hostname, port = 443, dir="node2", uid='test', pwd='test')
}, silent=T)
node1
node1$ops
node1$ops$`_thread`()
#loadtest
#
library(future)
N <- 10
N <- 10
for(k in 1:N){
ans[[k]] <- future(node1$ops$`_thread`(2))
}
ans <- list()
N <- 10
for(k in 1:N){
ans[[k]] <- future(node1$ops$`_thread`(2))
}
ans[[1]]
sapply(ans, resolved)
for(k in 1:N){
ans[[k]] <- future(node1$ops$`_thread`(2))
}
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
ans[[k]] <- future(node2$ops$`_thread`(5))
for(k in 1:N){
ans[[k]] <- future(node2$ops$`_thread`(5))
}
sapply(ans, resolved)
sapply(ans, resolved)
ans[[5]]
node2$ops$`_thread`(10)
node2$ops$`_thread`(10) %>% httr::content()
node2$ops$`_thread`() %>% httr::content()
#* thread
#* @param t process time
#* @get /thread
#* @json
thread <- function(t = 1) {
# init logging
process_name <- 'thread' # this name is crucial for process logging and status checking
pid <- get_pid(process_name) # get the last process id for this process
pid_info <- get_pid_info(pid) # get the info to the pid
# icheck if process is running or finished, if yes create new pid
if(pid_info$status != 'init') pid <- create_pid(process_name)
#flog.threshold(DEBUG)
flog.appender(appender.redis(pid))
flog.info('Process %s started', process_name)
set_pid_status(pid, 'running')
# do some stuff ##################
dummy_process(pid, t)
##################################
set_pid_status(pid, 'finished')
# wrap up
flog.info('Process %s finished', process_name)
output <- list(msg=glue("Process {process_name} finished!"),
log=get_pid_log(pid),
status = 'finished')
output
}
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
source('~/Repos/QAF/node/run_api.R', echo=TRUE)
ans <- list()
N <- 10
for(k in 1:N){
ans[[k]] <- future(node2$ops$`_thread`(5))
}
sapply(ans, resolved)
sapply(ans, resolved)
node2$ops$`_thread`(5)
sapply(ans, resolved)
N <- 3
for(k in 1:N){
ans[[k]] <- future(node2$ops$`_thread`(20))
}
sapply(ans, resolved)
ans <- list()
N <- 3
for(k in 1:N){
ans[[k]] <- future(node2$ops$`_thread`(20))
}
sapply(ans, resolved)
ans[[2]]
value(ans[[2]])
# ignore certificate
set_config(config(ssl_verifypeer = 0L, ssl_verifyhost=0L))
node2$ops$`_thread`(20)
for(k in 1:N){
ans[[k]] <- future({
set_config(config(ssl_verifypeer = 0L, ssl_verifyhost=0L))
node2$ops$`_thread`(20)
})
}
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
ans <- list()
N <- 3
for(k in 1:N){
ans[[k]] <- future({
set_config(config(ssl_verifypeer = 0L, ssl_verifyhost=0L))
node2$ops$`_thread`(5)
})
}
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, resolved)
ans
sapply(ans, httr::content)
sapply(ans, function(x) value(x) %>% httr::content)
sapply(ans, function(x) value(x) %>% httr::content)
sapply(ans, function(x) value(x) %>% httr::content())
for(k in 1:N){
ans[[k]] <- future({
set_config(config(ssl_verifypeer = 0L, ssl_verifyhost=0L))
node2$ops$`_thread`(5)
})
}
sapply(ans, resolved)
for(k in 1:N){
ans[[k]] <- future({
set_config(config(ssl_verifypeer = 0L, ssl_verifyhost=0L))
node2$ops$`_thread`(5)
})
}
sapply(ans, resolved)
sapply(ans, resolved)
sapply(ans, function(x) value(x) %>% httr::content())
sapply(ans, resolved)
sapply(ans, function(x) value(x) %>% httr::content())
?value
N <- 20
for(k in 1:N){
ans[[k]] <- future({
set_config(config(ssl_verifypeer = 0L, ssl_verifyhost=0L))
node2$ops$`_thread`(5)
})
}
N <- 20
for(k in 1:N){
ans[[k]] <- future({
set_config(config(ssl_verifypeer = 0L, ssl_verifyhost=0L))
node2$ops$`_thread`(1)
})
}
sapply(ans, resolved)
sapply(ans, function(x) value(x) %>% httr::content())
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
titlePanel("Hello Shiny!")
)
shinyApp(ui, server = function(input, output) { })
}
source('~/.active-rstudio-document', echo=TRUE)
library(shiny)
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
titlePanel("Hello Shiny!")
)
shinyApp(ui, server = function(input, output) { })
}
?dashboardPage
# Define packages
pkgs <- c('tidyverse',
#'plotly',
#'RColorBrewer',
'shiny',
'shinyjs',
'shinydashboard',
'dashboardthemes',
#'DT'
'rapiclient',
'jsonlite',
'httr',
'swagger'
)
# load packages
loadflag <- sapply(pkgs, require, character.only = T, quietly = T)
?dashboardPage
runApp('client')
